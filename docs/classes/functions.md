# Функции-конструкторы

## Оператор new

`new` создаёт новый экземпляр объекта, имеющего конструктор.

[filename](functions.js ':include :type=code :fragment=newfoo')

Для выполнения этого кода движок:

1. Создает новый объект, наследующий Foo.prototype

2. Вызывает конструктор - функцию Foo с указанными аргументами и `this`, привязанным к созданному новому объекту.

3. Если функция-конструктор не возвращает значение, по умолчанию возвращается созданный объект.

## Принципы ООП

Раз Javascript сильный и независимый объектно-ориентированный язык, попробуем на основе этих типов объектов применить основные принципы ООП.

### Инкапсуляция

Наши объекты должны быть "черными ящиками", т.е. их пользователи должны видеть только интерфейс, и не иметь возможности влезть во внутреннюю реализацию.

[filename](functions.js ':include :type=code :fragment=incapsulation-bad')

В данном примере любой внешний пользователь нашего типа может получить доступ к данным напрямую, и у нас нет никакой возможности проверить, что значение полученное на вход действительно валидное. Попробуем решить это спрятав взаимодействие с переменной в функции.

[filename](functions.js ':include :type=code :fragment=incapsulation-attempt')

Здесь уже есть возможность проверить значение, которое устанавливается в переменную. Но пользователь нашего типа все еще может все сломать, если он решит не пользоваться нашим методом. Чтобы это сделать, нам нужно спрятать переменные, воспользовавшись принципом *замыкания*

[filename](functions.js ':include :type=code :fragment=incapsulation-attempt')

Замыкание позволяет нам получить доступ к переменным снаружи внутреннего объекта, который возвращает конструктор. Таким образом мы не дадим пользователю прямой доступ к данным, с которыми работает наш новый тип.

### Наследование, Абстракция, Полиморфизм

Потребуют от нас умения работы с [прототипами](./prototypes.md)
