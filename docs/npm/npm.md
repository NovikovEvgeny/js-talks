# NPM

npm - node package manager - менеджер пакетов JS

> Есть такая игра на выпивку: Игроки по очереди говорят любые английские слова, забивают в гугл,
>и, если есть такой npm пакет, то выпивают. Не играйте в эту игру, это опасно для жизни! 


Вообще, npm - [самый большой репозиторий пакетов](https://www.opennet.ru/opennews/art.shtml?num=45861), 
и стал он таким еще в 2017 году. Это и хорошо (очень много кода написано за нас), и плохо (по факту, нпм - это помойка, в которую очень легко добавить свою кучу мусора)

## Что такое npm-пакет

npm-пакет - обычно какая-то библиотека. Может быть что то посложнее (типа целых фреймворков - Angular, Nest.js), а могут быть и 
однострочники, типа [negative-zero](https://github.com/sindresorhus/negative-zero/blob/master/index.js)


Под капотом, npm-пакет - набор .js файлов. Небольшое приложение, которое предназначено для многократного использования
в других приложениях. Обычно у пакета либо есть один entrypoint, либо это набор мини-библиотечек, которые можно импортить по одной 

## Создание npm-пакета

По факту, npm-пакет - просто JS приложение. Набор JS файлов с парой дополнительных файлов типа `package.json` и `.npmignore`

### Создаем проект

```
mkdir js-talks-lesson
cd js-talks-lesson

npm init
// fill info
```

## Наполняем проект кодом

index.js
```javascript
function sayHi(name) {
  console.log(`Hi, ${name}`);
  return `Modified ${name}`; 
}

module.exports.sayHi = sayHi;

```

## Паблишим первую версию пакета

```
npm login 
npm publish
```

Заходим на npmjs.org, видим наш пакет. Сразу видны:
- история версий
- зависимости
- зависимые проекты
- ссылка на GitHub (если указан репозиторий)
- ссылка на Readme
- ссылка на Issues (если указан репозиторий)


Проблема - нет описания проекта! На месте, где должна быть основная страница с документацией,
текст ошибки о том, что файл не найден

## Добавляем README.md

В корне проекта:

```
touch README.md
// fill README.md
```

## Паблишим новую версию

```
npm version patch
npm publish
```

## Добавляем зависимости

```
npm install jsdoc
```

## Генерируем доку

```
npx jsdoc index.js
```

## Обновляем версию

```
npm version patch
npm publish
```

## Обновляем версию в зависимом пакете

```
npm install --save js-talks-lesson
```

## Ужасаемся
Вместе с `js-talks-lesson` у нас установился jsdoc и все его зависимости!
Плохо, потому что `jsdoc` зависимость не нужна для использования этой библиотеки. Он не несет никакой полезной
функциональности "в продакшене".

jsdoc нужен только на этапе разработки. 
 
### dependencies vs devDependencies

[devDependencies](https://docs.npmjs.com/specifying-dependencies-and-devdependencies-in-a-package-json-file), 
в отличие от `dependencies`, не "тянутся" вслед за библиотекой при её установке как зависимости. 

Это единственная разница. Так что стоит активно использовать это свойство и сохранять как `devDependency` все
зависимости, которые не нужны для работы "в проде". Тестовые фреймворки, вспомогательные тулы, typescript и все, что
не нужно.

## Меняем зависимости
```
npm uninstall jsdoc
npm install --save-dev jsdoc


npm version patch
npm publish
```

## Лишние файлы

Обновляем модуль в зависимом проекте:
```
npm install
```

Ничего не произошло. Т.к. в нашем зависимом проекте уже создан `package-lock.json` файл, который
содержит в себе точный список зависимостей (и их зависимостей, и зависимостей зависимостей и т.д.) с точными
номерами версий, которые были последний раз установлены. Это позволяет всегда быть уверенным, что весь набор зависимостей
постояннен и не будет случайно изменен. [Больше - в документации npm](https://docs.npmjs.com/configuring-npm/package-lock-json.html)

Делаем явное изменение номера версии:

```
npm upgrade js-talks-lesson
```

Видим, что версия обновилась.
Открываем `node_modules/js-talks-lesson` и видим еще одну бесполезную папку `out`.
Она была сгенерирована с помощью `jsdoc` и нужна, например, для паблиша её на GitHub Pages (или любой другой сервер),
но этот набор файлов внутри `node_modules` нам не нужен. Мы просто заставили npm качать больше файлов

## Добавляем .npmignore
```
touch .npmignore
echo out/ > .npmignore
```

```
npm version patch
npm publish
```

В зависимом проекте:
```
npm upgrade js-talks-lesson
```

Открываем `node_modules/js-talks-lesson` и видим, что папки `out/` больше нет. Так можно добавлять любые файлы, которые
не нужны при работе библиотеки "в проде". Это могут быть всякие `.eslintrc`, `.tsconfig`, `Dockerfile` да и вообще что угодно.

## Делаем мажорное изменение API

npm поддерживает [semantic versioning](https://docs.npmjs.com/about-semantic-versioning), что позволяет 
нам явно указывать диапазон версий зависимости, которые должны быть установлены в проект.

Представим, что мы меняем наш модуль и вносим т.н. breaking changes - изменения, которые поломают работу библиотеки 
в уже существующих зависимых проектах:

index.js
```
/**
 * Prints name to console
 *
 * @param {number} number number of times to print in console
 * @param {string} name your name
 * @returns {string} modified name
 */
function sayHi(number, name) {
  for (let i = 0; i < number; i++) {
    console.log(`Hi, ${name}`);
  }
  return `Modified ${name}`;
}

module.exports.sayHi = sayHi;

```

Обратите внимание на то, что в `sayHi` теперь первым аргументом передается число, а не имя.
То есть, такое изменение не имеет совместимости с предыдущими версиями

Следовательно, так как мы хорошие и ответственные программисты, мы сообщаем о том, что обновленная версия билиотеки
содержит "мажорные" изменения и может не работать со "старым" кодом.
Это делается путем обновления "мажорной" части версии (первой циферки)

```
npm version major
npm publish
```

В отличие от прошлых `npm version patch`, где обновлялась "третья" цифра в версии, теперь версия составляет `2.0.0`

## Убеждаемся, что ^ работает корректо

Теперь что бы вы ни делали в *зависимом проекте*, автоматического обновления версии до 2.0.0 не произойдет, т.к.
в зависимом проекте в Dependencies стоит `"js-talks-lesson": "^1.0.0"`

Ни удаление `package-lock.json` и затем `npm install`, ни `npm upgrade js-talks-lesson` не установят
версию 2.0.0, т.к. это не соответствует условиям, указанным в номере версии - а именно `^`, т.к. этот символ
явно указывает на то, чт можно обновляться до любой версии кроме "мажорной". Подробнее об этом - 
на [странице npm](https://docs.npmjs.com/about-semantic-versioning)


Чтобы обновить версию, нам явно надо изменить и поставить версию `^2.0.0` и просто сделать `npm install`

Тогда, даже если в вашем `package-lock.json` указана версия 1.x.x, то npm все равно обновит библиотеку, т.к.
эта версия не попадает под условия, описанные в `package.json`

!> **Note:** Никогда не получится запаблишить пакет с такой же комбинацией имя + версия. Даже если вы удалили пакет из npm с
помощью `npm unpublish`, то ту уже выложенную версию не получится "переписать". 

## Install scripts

install.js
```
console.log("Hey, you're installing my package! Congrats!!!!");

console.log("Please, send 100$ to my phone +7-981-123-45-67");
```

package.json:
```
{
...
  "scripts": {
    "install": "node install.js"
  }
}
```

При установке этого пакета как зависимости, всегда будет запускаться `node install.js` и мы в консоли увидим эти логи.
Логи и просьба донатов, конечно, хорошее применение этому инструменту, но вообще он служит для более серьезных задач.

Например, [взгляните на install-scripts в библиотеке puppeteer](https://github.com/puppeteer/puppeteer/blob/master/install.js)
это цельная программа, которая делает множество подготовительных вещей для того, чтобы правильно установить эту библиотеку.

Больше о разных npm-scripts читайте в [официальной документации](https://docs.npmjs.com/misc/scripts)

## global modules

При установке модуля с флагом `-g` или `--global`, пакет ставится глобально - не в проект, а в систему. И его можно использовать
как CLI утилиту. Например, сам npm и есть такой глобальный JS пакет.

Добавим в наш модуль возможность установки глобально:

global.js
```
#!/usr/bin/env node

const sw = require('./index');

sw.sayHi(2, process.argv[2]);
```


package.json:
```
{
...
  "bin": {
    "js-talks-lesson": "./global.js"
  },
...
}
```


Обновляем пакет, публикуем его. Устанавливаем глобально: `npm install js-talks-lesson -g`

После этого можно попробовать запустить наш пакет как CLI-утилиту:

```
js-talks-lesson Evgeniy

Hi, Evgeniy
Hi, Evgeniy
```

Магия! Запускаем JS прямо из обычной консоли

[Больше примеров можно найти тут](https://medium.com/@thatisuday/creating-cli-executable-global-npm-module-5ef734febe32)

## scoped packages, private repositories    

[Scope packages](https://docs.npmjs.com/using-npm/scope.html)

[.npmrc](https://docs.npmjs.com/configuring-npm/npmrc.html)-файлы для проектов - отличная идея для совмещения публичного npmjs.org и приватного npm-репозитория